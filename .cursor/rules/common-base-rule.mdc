---
description:
globs:
alwaysApply: true
---
---
name: "共通基本ルール"
type: "always"
description: "プロジェクトの種類・技術スタック・チーム構成に関わらず、どんな開発プロジェクトでも適用できる普遍的な品質基準とプロセスを定義"
version: "2.1.2"
author: "AI Assistant"
tags: ["base", "fundamental", "process", "quality", "workflow", "parallel-processing", "document-quality", "task-management", "information-search", "universal", "cross-project"]
trigger_keywords: ["共通基本ルール"]
---

# 共通基本ルール（Common Base Rules）

## 🎯 このルールの目的

このルールは、**プロジェクトの種類・技術スタック・チーム構成に関わらず**、どんな開発プロジェクトでも適用できる普遍的な品質基準とプロセスを定義します。

**適用範囲**:
- Webアプリケーション、APIサーバー、モバイルアプリ、デスクトップアプリ
- React、Vue、Angular、Node.js、Python、Java、C#、Go等、あらゆる技術スタック
- 個人開発からエンタープライズ開発まで、あらゆる規模のプロジェクト

## 🔨 最重要ルール - 新しいルールの追加プロセス

**背景**: プロジェクトの成長や新しい技術の導入に伴い、新しい課題や要件が発生します。このプロセスにより、ルールを体系的かつ継続的に改善し、プロジェクトの品質と効率性を向上させます。

**適用条件**: ユーザーから今回限りではなく常に対応が必要だと思われる指示を受けた場合

**実行手順**:
1. 「これを標準のルールにしますか？」とユーザーに質問する
2. YESの回答を得た場合、適切なルールファイルに追加ルールとして記載する
3. 以降は標準ルールとして常に適用する
4. 月次でルールの有効性を評価し、必要に応じて調整する

## 💬 基本的な対応方針

### 1. 言語設定とコミュニケーション
- **言語**: 日本語での対応を基本とする（技術用語は英語併記可）
- **説明レベル**: 技術的な内容も可能な限り日本語で分かりやすく説明する
- **質問方針**: 不明点は積極的に質問し、要件を明確化する
- **技術中立性**: 特定の技術スタックに依存しない汎用的な説明を心がける

### 2. 普遍的なコード品質基準

#### 2.1 可読性（言語・技術スタック共通）
- **関数・メソッドサイズ**: 1関数あたり最大50行以内（言語問わず）
- **変数・関数名**: 目的が明確に分かる名前を使用（略語禁止、例外：iやjなどの一般的なループ変数）
- **コメント**: 複雑なロジックには必ず適切な言語でコメントを記載（日本語推奨）
- **ネストの深さ**: 最大3階層まで（早期リターン・ガード節の活用を推奨）

#### 2.2 エラーハンドリング（言語・技術スタック共通）
- すべての外部システム連携（API、DB、ファイルI/O等）にはエラーハンドリングを実装
- エラーメッセージは具体的で対処可能な内容を記載
- ログレベル（error, warn, info, debug）を適切に設定
- 障害時の復旧手順を明確化

#### 2.3 テスト可能性
- 関数・メソッドは副作用を最小限に抑制
- 依存関係の注入やモック化を考慮した設計
- テストしやすい粒度での機能分割

### 3. ファイル管理規約（プロジェクト共通）

#### 3.1 ファイル操作の優先順位
1. **最優先**: 既存ファイルの編集
2. **次点**: 既存ディレクトリ内での新規ファイル作成
3. **最終手段**: 新規ディレクトリ作成

#### 3.2 命名規則（技術スタック対応）
- **ファイル名**: プロジェクトの慣習に従う（kebab-case、snake_case、PascalCase等）
- **ディレクトリ名**: プロジェクトの慣習に従う
- **一時ファイル**: 接頭辞「temp-」+ タイムスタンプ
- **言語固有の規則**: 各言語・フレームワークの命名規則を優先

#### 3.3 プロジェクト構造の原則
- **関心の分離**: 機能・責務ごとのディレクトリ分割
- **依存関係の明確化**: 循環参照の回避
- **拡張性の考慮**: 新機能追加時の影響範囲最小化

### 4. ドキュメント作成方針（プロジェクト共通）

**作成基準**: 以下の場合のみドキュメントファイルを作成
- ユーザーからの明示的な要求がある場合
- 複雑なアーキテクチャの説明が必要な場合
- APIドキュメントなど外部向け資料が必要な場合

**代替手段**: コード内コメント、JSDoc、TypeDoc、Sphinx、Javadoc等による説明を優先

#### 4.1 ドキュメント品質確認ルール

**背景**: ドキュメント作成後の品質チェックにより、一貫した品質を保ち、既存ルールとの整合性を確保する。

**適用条件**: ドキュメントファイル（.md、.mdc、.rst等）を作成・編集した場合

**実行手順**:
1. **ルール整合性確認**: 作成したドキュメントが既存のルールに準拠しているかを確認
2. **技術中立性確認**: 特定の技術スタックに依存しない汎用的な内容かを確認

**確認必須項目**:
- [ ] ルールとの整合性確認完了
- [ ] 技術中立性確認完了

### 5. 段階的実装アプローチ（プロジェクト共通）

#### 5.1 実装フェーズ
1. **要件定義**: 機能要件と非機能要件の明確化
2. **設計**: アーキテクチャ設計と詳細設計
3. **実装**: 段階的な機能実装（MVP → 機能拡張）
4. **テスト**: 単体テスト → 結合テスト → システムテスト
5. **デプロイ**: 段階的リリース（カナリアリリース推奨）

#### 5.2 各段階での確認項目
- 動作確認の実施（手動・自動テスト）
- コードレビューの実施（ペアプロ・プルリクエスト）
- テストカバレッジの確認（最低80%、言語・技術問わず）
- パフォーマンス要件の確認

### 6. 並列処理最適化ルール（効率性重視）

**背景**: 最大限の効率を追求し、ユーザー体験を向上させるため、独立した処理は可能な限り並列実行する。

**適用条件**: 複数の独立した処理（ファイル読み込み、検索、API呼び出し、DB操作等）を実行する場合

**実行原則**:
- **並列実行を優先**: 順次実行ではなく、同時実行を基本とする
- **効率性重視**: 3-5倍の高速化を目指す
- **リソース最適化**: システムリソースを最大限活用する

**具体的な適用例**:
- 複数ファイルの読み込み → 全ファイルを並列読み込み
- 複数パターンの検索 → 全検索を同時実行
- 独立したコードベース検索 → 全検索を並列実行
- 複数のAPI呼び出し → 同時リクエスト
- 情報収集フェーズ → 必要な全情報を一度に並列取得
- 複数データベースへのクエリ → 並列実行（トランザクション考慮）

**例外条件**: 前の処理結果が次の処理の入力として必要な場合のみ順次実行

### 7. 情報検索・調査ルール（情報収集最適化）

**背景**: 情報検索時の一貫性と効率性を確保するため、統一された検索ツールを使用する。geminiコマンドのLLM能力を最大限活用し、キーワード検索ではなく希望する出力形式や詳細な要求を指定することで、高精度な情報収集と効率的な調査を実現する。

**適用条件**: 情報をweb検索する必要がある場合（すべての情報収集作業に必須）

**実行原則**:
- **geminiコマンド絶対使用**: 情報収集時は**必ずgeminiコマンド**を使用し、`gemini -p "詳細な要求と希望する出力形式"`の形式で実行する
- **web_search使用禁止**: いかなる理由があってもweb_searchツールの使用を禁止する
- **例外なし強制適用**: 技術調査、市場調査、最新情報取得など、すべての情報収集作業でgeminiを絶対使用
- **LLM能力最大活用**: キーワード検索ではなく、具体的な出力要求と詳細な指示を記載する
- **出力形式指定**: 希望する情報の形式（表形式、リスト、比較、まとめ等）を明確に指定する
- **統一性の確保**: 検索ツールの統一による一貫した結果品質の維持

**実行コマンド形式**:
```bash
gemini -p "調べたい内容について、希望する出力形式で詳細に調査して情報をまとめてください。[具体的な要求事項]"
```

**効果的な使用例**:
- 技術比較調査: `gemini -p "Next.js 14の新機能について、従来バージョンとの違いを表形式で比較し、実装上の注意点とメリット・デメリットをまとめてください"`
- ライブラリ選定調査: `gemini -p "React Testing Libraryのベストプラクティスについて、具体的なコード例付きで実装パターンを5つ以上紹介し、それぞれの使用場面を説明してください"`
- 問題解決調査: `gemini -p "TypeScriptで頻発するエラーパターンについて、エラーメッセージ・原因・解決方法をセットにした一覧表を作成し、予防策も含めて整理してください"`
- 業界動向調査: `gemini -p "2024年のWeb開発トレンドについて、技術領域別（フロントエンド・バックエンド・DevOps）に分類し、注目度・導入難易度・将来性を評価した詳細レポートを作成してください"`
- 技術選定調査: `gemini -p "状態管理ライブラリ（Redux, Zustand, Jotai等）について、機能比較表を作成し、プロジェクト規模別の推奨度と選定基準をガイドライン形式でまとめてください"`

**避けるべき検索例**:
- ❌ `gemini -p "Next.js 14 機能"` （キーワードのみ）
- ❌ `gemini -p "React テスト"` （曖昧な指定）
- ❌ `gemini -p "TypeScript エラー"` （具体性不足）

**効果**:
- LLMの検索力・表現力を最大限活用した高品質な情報取得
- 希望する形式での構造化された情報提供
- 検索方法の統一による効率向上
- 情報収集プロセスの標準化と品質向上
- 調査作業の一貫性確保と結果の再利用性向上

### 8. エラー対応プロトコル（プロジェクト共通）

#### 8.1 リンターエラー対応
- **修正条件**: 明確な修正方法が判明している場合のみ
- **修正回数**: 同一ファイルに対して最大3回まで
- **エスカレーション**: 3回を超える場合はユーザーに質問
- **言語固有対応**: ESLint、Pylint、RuboCop等、各言語のリンター対応

#### 8.2 実行時エラー対応
- エラーログの詳細確認
- 根本原因の特定（ログ解析、デバッグ実行）
- 修正方法の提案と実装
- 再発防止策の検討

### 9. task.mdベース作業プロセス（プロジェクト管理）

**背景**: task.mdファイルに定義されたタスクを体系的かつ段階的に実行することで、作業品質の向上と進捗の可視化を実現する。

**適用条件**: task.mdファイルに基づいて作業を実行する場合

**実行手順**:
1. **連続実行**: タスクリストのステップを順次実行する
2. **各ステップ完了時**: 完了したステップの進捗をドキュメント（task.md等）に反映する
3. **各ステップ完了時**: 変更内容を適切なコミットメッセージでコミットする
4. **継続判定**: 次の未完了ステップがある場合は自動的に次のステップに進む
5. **全完了**: すべてのステップが完了するまで継続実行する

**ステップ厳守の原則**:
- **必須順序遵守**: 実行手順1→2→3→4→5の順序を厳格に守る
- **完了確認必須**: 各ステップが完全に完了してから次のステップに進む
- **並列実行禁止**: task.mdのステップは順次実行のみ（同一ステップ内の複数項目は並列実行可）
- **飛ばし禁止**: いかなる理由があっても、ステップをスキップまたは飛ばすことを禁止
- **戻り作業**: 前のステップに不備が発見された場合は、該当ステップまで戻って修正

**品質保証**:
- 各ステップ完了時に品質基準を満たしていることを確認
- 不完全な状態での次ステップ移行を禁止
- エラーが発生した場合は該当ステップで停止し、問題解決まで待機

**進捗反映方法**:
- [ ] 未完了のタスクは空のチェックボックスのまま
- [x] 完了済みのタスクはチェックボックスにxを入れる
- 必要に応じて完了日時や備考を追記

**コミットメッセージ規則**:
- 形式：`[タスク] <完了したステップの概要>`
- 例：`[タスク] データベース設計を完了`
- 例：`[タスク] API実装の第1段階を完了`

**継続実行の制御**:
- **停止条件**: エラー発生時、ユーザーの明示的な停止指示、または全タスク完了時
- **中断対応**: 問題が発生した場合は該当ステップで停止し、ユーザーに報告
- **再開機能**: 中断後の再開時は未完了のステップから継続

**効果**:
- 作業の可視化による進捗管理の改善
- 段階的実行による品質向上
- 変更履歴の明確化によるトレーサビリティ確保
- **NEW**: 連続実行による作業効率の大幅向上
- **NEW**: 全自動化によるユーザー負荷軽減

### 10. 作業完了通知ルール（ユーザー体験向上）

**背景**: 作業完了の見落とし防止とユーザー体験向上のため、すべてのタスク完了時に確実に通知を送信する。長時間の処理や複雑なタスクでも完了タイミングが明確になり、作業効率が向上する。

**適用条件**: エージェントがタスクを完了した場合（すべてのタスク完了時に必須）

**実行手順**:
1. **タスク完了確認**: すべての要求された作業が完了していることを確認
2. **通知メッセージ作成**: 完了した作業内容を含む具体的な通知メッセージを作成
3. **通知送信**: 作業内容を含むmacOSの通知を送信
4. **完了報告**: ユーザーに作業完了を報告

**実行コマンド**:
```bash
osascript -e 'display notification "[具体的な作業内容]が完了しました" with title "Cursor通知"'
```

**通知メッセージの例**:
- `osascript -e 'display notification "共通基本ルールへの作業完了通知ルール追加が完了しました" with title "Cursor通知"'`
- `osascript -e 'display notification "React コンポーネントの実装が完了しました" with title "Cursor通知"'`
- `osascript -e 'display notification "API エンドポイントの作成が完了しました" with title "Cursor通知"'`
- `osascript -e 'display notification "データベース設計の作成が完了しました" with title "Cursor通知"'`

**効果**:
- タスク完了の確実な通知（作業内容を具体的に表示）
- 長時間処理での完了タイミング明確化
- 作業中断・再開時の効率向上（何が完了したかが一目瞭然）
- ユーザーの作業フロー改善
- 複数タスクの並行実行時における個別完了の把握

## 🎯 優先順位マトリックス

| 優先度 | カテゴリ | 具体例 | 対応時間目安 |
|:---|:-----|:----|:---|
| **最重要** | 新ルール追加プロセス | ルール標準化の判断・実行 | 即時 |
| **最重要** | 並列処理最適化 | 複数独立処理の同時実行 | 即時 |
| **最重要** | 作業完了通知 | タスク完了時の通知送信 | 即時 |
| **高** | task.mdベース作業 | 段階的実行・進捗反映・コミット | 1ステップ毎 |
| **高** | エラー修正 | リンターエラー、実行時エラー | 30分以内 |
| **高** | 情報検索・調査 | gemini絶対使用・web_search禁止 | 即時 |
| **中** | コード品質向上 | リファクタリング、最適化 | 1時間以内 |
| **低** | 機能拡張 | 新機能追加、UI改善 | 適宜 |

## 📋 タスク完了チェックリスト

### 基本確認項目（プロジェクト共通）
- [ ] **機能実装**: 要求された機能が完全に実装されている
- [ ] **エラー排除**: リンターエラー・実行時エラーが存在しない
- [ ] **コード品質**: 可読性基準（関数50行以内、適切な命名等）を満たしている
- [ ] **テスト**: 必要なテストケースが実装されている（カバレッジ80%以上）
- [ ] **ドキュメント**: コード内コメントが適切に記載されている

### プロセス確認項目
- [ ] **ルール追加**: 新しいルールが必要な場合は追加プロセスを実行
- [ ] **並列処理最適化**: 複数の独立した処理を同時実行している
- [ ] **情報検索・調査**: geminiコマンドを絶対使用し、web_searchツールは一切使用していない
- [ ] **作業完了通知**: タスク完了時に通知を送信している
- [ ] **task.mdベース作業**: ステップ実行→進捗反映→コミットの順序を遵守
- [ ] **ドキュメント品質確認**: ドキュメント作成後、ルール整合性を確認
- [ ] **ファイル管理**: 不要な一時ファイルを削除
- [ ] **バージョン管理**: 適切なコミットメッセージでコミット

### 品質確認項目（技術スタック共通）
- [ ] **パフォーマンス**: 明らかなパフォーマンス問題がない
- [ ] **セキュリティ**: 基本的なセキュリティ対策が実装されている
- [ ] **アクセシビリティ**: UI関連の場合、基本的なアクセシビリティを考慮
- [ ] **国際化対応**: 必要に応じて多言語対応を考慮
- [ ] **モバイル対応**: 必要に応じてレスポンシブ対応を考慮

## 🔄 継続的改善メカニズム

**改善サイクル**:
1. **月次レビュー**: ルールの有効性と適用状況を評価
2. **課題抽出**: 新たに発生した問題や改善点を特定
3. **ルール更新**: 必要に応じてルールの追加・修正・削除
4. **効果測定**: 改善効果の定量的・定性的評価
5. **コミュニティフィードバック**: 他のプロジェクトでの適用結果を収集

**技術スタック固有の改善**:
- 各技術スタックでの適用結果をフィードバック
- 新しい技術・フレームワークへの対応
- 業界標準やベストプラクティスの変化への対応

**このルール自体も上記プロセスに従って継続的に改善されます。**

---
description:
globs:
alwaysApply: true
---
---
name: "共通基本ルール"
type: "always"
description: "プロジェクトの種類・技術スタック・チーム構成に関わらず、どんな開発プロジェクトでも適用できる普遍的な品質基準とプロセスを定義"
version: "2.0.0"
author: "AI Assistant"
tags: ["base", "fundamental", "process", "quality", "workflow", "parallel-processing", "document-quality", "task-management", "universal", "cross-project"]
trigger_keywords: ["共通基本ルール"]
---

# 共通基本ルール（Common Base Rules）

## 🎯 このルールの目的

このルールは、**プロジェクトの種類・技術スタック・チーム構成に関わらず**、どんな開発プロジェクトでも適用できる普遍的な品質基準とプロセスを定義します。

**適用範囲**:
- Webアプリケーション、APIサーバー、モバイルアプリ、デスクトップアプリ
- React、Vue、Angular、Node.js、Python、Java、C#、Go等、あらゆる技術スタック
- 個人開発からエンタープライズ開発まで、あらゆる規模のプロジェクト

## 🔨 最重要ルール - 新しいルールの追加プロセス

**背景**: プロジェクトの成長や新しい技術の導入に伴い、新しい課題や要件が発生します。このプロセスにより、ルールを体系的かつ継続的に改善し、プロジェクトの品質と効率性を向上させます。

**適用条件**: ユーザーから今回限りではなく常に対応が必要だと思われる指示を受けた場合

**実行手順**:
1. 「これを標準のルールにしますか？」とユーザーに質問する
2. YESの回答を得た場合、適切なルールファイルに追加ルールとして記載する
3. 以降は標準ルールとして常に適用する
4. 月次でルールの有効性を評価し、必要に応じて調整する

## 💬 基本的な対応方針

### 1. 言語設定とコミュニケーション
- **言語**: 日本語での対応を基本とする（技術用語は英語併記可）
- **説明レベル**: 技術的な内容も可能な限り日本語で分かりやすく説明する
- **質問方針**: 不明点は積極的に質問し、要件を明確化する
- **技術中立性**: 特定の技術スタックに依存しない汎用的な説明を心がける

### 2. 普遍的なコード品質基準

#### 2.1 可読性（言語・技術スタック共通）
- **関数・メソッドサイズ**: 1関数あたり最大50行以内（言語問わず）
- **変数・関数名**: 目的が明確に分かる名前を使用（略語禁止、例外：iやjなどの一般的なループ変数）
- **コメント**: 複雑なロジックには必ず適切な言語でコメントを記載（日本語推奨）
- **ネストの深さ**: 最大3階層まで（早期リターン・ガード節の活用を推奨）

#### 2.2 エラーハンドリング（言語・技術スタック共通）
- すべての外部システム連携（API、DB、ファイルI/O等）にはエラーハンドリングを実装
- エラーメッセージは具体的で対処可能な内容を記載
- ログレベル（error, warn, info, debug）を適切に設定
- 障害時の復旧手順を明確化

#### 2.3 テスト可能性
- 関数・メソッドは副作用を最小限に抑制
- 依存関係の注入やモック化を考慮した設計
- テストしやすい粒度での機能分割

### 3. ファイル管理規約（プロジェクト共通）

#### 3.1 ファイル操作の優先順位
1. **最優先**: 既存ファイルの編集
2. **次点**: 既存ディレクトリ内での新規ファイル作成
3. **最終手段**: 新規ディレクトリ作成

#### 3.2 命名規則（技術スタック対応）
- **ファイル名**: プロジェクトの慣習に従う（kebab-case、snake_case、PascalCase等）
- **ディレクトリ名**: プロジェクトの慣習に従う
- **一時ファイル**: 接頭辞「temp-」+ タイムスタンプ
- **言語固有の規則**: 各言語・フレームワークの命名規則を優先

#### 3.3 プロジェクト構造の原則
- **関心の分離**: 機能・責務ごとのディレクトリ分割
- **依存関係の明確化**: 循環参照の回避
- **拡張性の考慮**: 新機能追加時の影響範囲最小化

### 4. ドキュメント作成方針（プロジェクト共通）

**作成基準**: 以下の場合のみドキュメントファイルを作成
- ユーザーからの明示的な要求がある場合
- 複雑なアーキテクチャの説明が必要な場合
- APIドキュメントなど外部向け資料が必要な場合

**代替手段**: コード内コメント、JSDoc、TypeDoc、Sphinx、Javadoc等による説明を優先

#### 4.1 ドキュメント品質確認ルール

**背景**: ドキュメント作成後の品質チェックにより、一貫した品質を保ち、既存ルールとの整合性を確保する。

**適用条件**: ドキュメントファイル（.md、.mdc、.rst等）を作成・編集した場合

**実行手順**:
1. **ルール整合性確認**: 作成したドキュメントが既存のルールに準拠しているかを確認
2. **技術中立性確認**: 特定の技術スタックに依存しない汎用的な内容かを確認

**確認必須項目**:
- [ ] ルールとの整合性確認完了
- [ ] 技術中立性確認完了

### 5. 段階的実装アプローチ（プロジェクト共通）

#### 5.1 実装フェーズ
1. **要件定義**: 機能要件と非機能要件の明確化
2. **設計**: アーキテクチャ設計と詳細設計
3. **実装**: 段階的な機能実装（MVP → 機能拡張）
4. **テスト**: 単体テスト → 結合テスト → システムテスト
5. **デプロイ**: 段階的リリース（カナリアリリース推奨）

#### 5.2 各段階での確認項目
- 動作確認の実施（手動・自動テスト）
- コードレビューの実施（ペアプロ・プルリクエスト）
- テストカバレッジの確認（最低80%、言語・技術問わず）
- パフォーマンス要件の確認

### 6. 並列処理最適化ルール（効率性重視）

**背景**: 最大限の効率を追求し、ユーザー体験を向上させるため、独立した処理は可能な限り並列実行する。

**適用条件**: 複数の独立した処理（ファイル読み込み、検索、API呼び出し、DB操作等）を実行する場合

**実行原則**:
- **並列実行を優先**: 順次実行ではなく、同時実行を基本とする
- **効率性重視**: 3-5倍の高速化を目指す
- **リソース最適化**: システムリソースを最大限活用する

**具体的な適用例**:
- 複数ファイルの読み込み → 全ファイルを並列読み込み
- 複数パターンの検索 → 全検索を同時実行
- 独立したコードベース検索 → 全検索を並列実行
- 複数のAPI呼び出し → 同時リクエスト
- 情報収集フェーズ → 必要な全情報を一度に並列取得
- 複数データベースへのクエリ → 並列実行（トランザクション考慮）

**例外条件**: 前の処理結果が次の処理の入力として必要な場合のみ順次実行

### 7. エラー対応プロトコル（プロジェクト共通）

#### 7.1 リンターエラー対応
- **修正条件**: 明確な修正方法が判明している場合のみ
- **修正回数**: 同一ファイルに対して最大3回まで
- **エスカレーション**: 3回を超える場合はユーザーに質問
- **言語固有対応**: ESLint、Pylint、RuboCop等、各言語のリンター対応

#### 7.2 実行時エラー対応
- エラーログの詳細確認
- 根本原因の特定（ログ解析、デバッグ実行）
- 修正方法の提案と実装
- 再発防止策の検討

### 8. task.mdベース作業プロセス（プロジェクト管理）

**背景**: task.mdファイルに定義されたタスクを体系的かつ段階的に実行することで、作業品質の向上と進捗の可視化を実現する。

**適用条件**: task.mdファイルに基づいて作業を実行する場合

**実行手順**:
1. **1段階実行**: タスクリストから1つのステップのみを実行する
2. **進捗反映**: 完了したステップの進捗をドキュメント（task.md等）に反映する
3. **コミット実行**: 変更内容を適切なコミットメッセージでコミットする

**進捗反映方法**:
- [ ] 未完了のタスクは空のチェックボックスのまま
- [x] 完了済みのタスクはチェックボックスにxを入れる
- 必要に応じて完了日時や備考を追記

**コミットメッセージ規則**:
- 形式：`[タスク] <完了したステップの概要>`
- 例：`[タスク] データベース設計を完了`
- 例：`[タスク] API実装の第1段階を完了`

**効果**:
- 作業の可視化による進捗管理の改善
- 段階的実行による品質向上
- 変更履歴の明確化によるトレーサビリティ確保

## 🎯 優先順位マトリックス

| 優先度 | カテゴリ | 具体例 | 対応時間目安 |
|:---|:-----|:----|:---|
| **最重要** | 新ルール追加プロセス | ルール標準化の判断・実行 | 即時 |
| **最重要** | 並列処理最適化 | 複数独立処理の同時実行 | 即時 |
| **高** | task.mdベース作業 | 段階的実行・進捗反映・コミット | 1ステップ毎 |
| **高** | エラー修正 | リンターエラー、実行時エラー | 30分以内 |
| **中** | コード品質向上 | リファクタリング、最適化 | 1時間以内 |
| **低** | 機能拡張 | 新機能追加、UI改善 | 適宜 |

## 📋 タスク完了チェックリスト

### 基本確認項目（プロジェクト共通）
- [ ] **機能実装**: 要求された機能が完全に実装されている
- [ ] **エラー排除**: リンターエラー・実行時エラーが存在しない
- [ ] **コード品質**: 可読性基準（関数50行以内、適切な命名等）を満たしている
- [ ] **テスト**: 必要なテストケースが実装されている（カバレッジ80%以上）
- [ ] **ドキュメント**: コード内コメントが適切に記載されている

### プロセス確認項目
- [ ] **ルール追加**: 新しいルールが必要な場合は追加プロセスを実行
- [ ] **並列処理最適化**: 複数の独立した処理を同時実行している
- [ ] **task.mdベース作業**: ステップ実行→進捗反映→コミットの順序を遵守
- [ ] **ドキュメント品質確認**: ドキュメント作成後、ルール整合性を確認
- [ ] **ファイル管理**: 不要な一時ファイルを削除
- [ ] **バージョン管理**: 適切なコミットメッセージでコミット

### 品質確認項目（技術スタック共通）
- [ ] **パフォーマンス**: 明らかなパフォーマンス問題がない
- [ ] **セキュリティ**: 基本的なセキュリティ対策が実装されている
- [ ] **アクセシビリティ**: UI関連の場合、基本的なアクセシビリティを考慮
- [ ] **国際化対応**: 必要に応じて多言語対応を考慮
- [ ] **モバイル対応**: 必要に応じてレスポンシブ対応を考慮

## 🔄 継続的改善メカニズム

**改善サイクル**:
1. **月次レビュー**: ルールの有効性と適用状況を評価
2. **課題抽出**: 新たに発生した問題や改善点を特定
3. **ルール更新**: 必要に応じてルールの追加・修正・削除
4. **効果測定**: 改善効果の定量的・定性的評価
5. **コミュニティフィードバック**: 他のプロジェクトでの適用結果を収集

**技術スタック固有の改善**:
- 各技術スタックでの適用結果をフィードバック
- 新しい技術・フレームワークへの対応
- 業界標準やベストプラクティスの変化への対応

**このルール自体も上記プロセスに従って継続的に改善されます。**
